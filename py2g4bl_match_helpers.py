import numpy as np
import matplotlib.pyplot as plt
import subprocess
from matplotlib.patches import Rectangle
import coolpy as cp

import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as mcolors
import matplotlib.patches as patches

def P(KE):
    'Kinetic energy in eV, muon mass in eV. Returns momentum in eV'
    m_mu = 105658375.55
    P=np.sqrt(KE**2 + 2*KE*m_mu)
    return P


def E_to_dpp_to_dE(Ekin, Espread):
    '''EKin in eV '''
    m_mu = 105658375.55 #eV
    np.random.seed(seed=1)
    nparticles = 100000
    KE_arr = np.random.normal(loc=Ekin, scale=Espread, size=nparticles)
    P_arr = np.sqrt((KE_arr + m_mu)**2 - m_mu**2)
    
    P_mean = np.mean(P_arr)
    P_std = np.std(P_arr)
    return(P_std) # in eV

def CellBeamGen(N, norm_emi_T, norm_emi_L, Eref, sigE, Bfield=40):
    #cellno, norm_emi_T [m], norm_emi_L [m], Eref [MeV], sigE [MeV], Bfield [T]
    c= cp.c #[m/s]
    m_mu = cp.m_mu * 1e-9 #GeV
    
    muPDG = 13
    mubPDG = -13
    #Pref = 0.19055 #ref momentum in GeV/c 
    #Pref = 0.15457055775549702
    
    #norm_emi_T = 300. * 1e-6 #[um -> m]
    #norm_emi_L = 1.5 * 1e-3  #[mm -> m]
    #Eref = 122.922733
    #sigE = 5.42169513 # Energy spread in [MeV]
    
    Pref = P(Eref*1E6)*1E-9
    
    beta = Pref / np.sqrt(Pref*Pref + m_mu*m_mu) #Unitless
    sigPZ = sigE / beta  #Momentum spread [MeV]
    Bz = Bfield #4.629 # low field at the beginning in [T]
    #Bz = 4.056486333380374
    
    #in GeV
    p = Pref
    beta0 = p*2/(0.29979258*Bz)
    kappa = (0.29979258*Bz) / (2 * p )
    alpha = 0.
    gamma = (1 + alpha**2) / beta0
    
    Lcan = 0. #canonical angular momentum at the start
    
    sigPX = np.sqrt(p*norm_emi_T*m_mu/(beta0)) * np.sqrt(2) #std of px in GeV/c
    sigX = np.sqrt(norm_emi_T*beta0*m_mu/p)# std of x in m
    
    xpx = -m_mu*norm_emi_T*alpha
    #angular kicks
    xpy = - m_mu * norm_emi_T* (beta0 * kappa - Lcan)
    ypx =  m_mu * norm_emi_T* (beta0 * kappa - Lcan)
    X0, Y0 = sigX , sigX #sigma_x/sigma_y in m
    XP0, YP0, PZ0 = sigPX , sigPX, sigPZ    #sigma_px/sigma_py in rad
    
    XPY0 = xpy
    YPX0 = ypx
    
    XPX0 = 0
    YPY0 = 0
    
    norm_emi_L_eV = norm_emi_L / c * cp.m_mu
    sigT = norm_emi_L_eV / (sigE * 1e6) #sigma t in [s]
    T0 = sigT * 1e9 #sigma t in [ns]
    
    mean = np.array([0, 0, 0, 0, 0, Pref*1e3])
    cov_matrix = np.array([[X0**2, XPX0  , 0.   , XPY0  , 0, 0     ],
                          [XPX0  , XP0**2, YPX0 , 0.    , 0, 0     ],
                          [0.    , YPX0  , Y0**2, YPY0  , 0, 0     ],
                          [XPY0  , 0.    , YPY0 , YP0**2, 0, 0     ],
                          [0.    , 0.    , 0.   , 0.    , T0**2, 0     ],
                          [0.    , 0.    , 0.   , 0.    , 0, PZ0**2]])
    
    
    macro = np.random.multivariate_normal(mean, cov_matrix, N)
    
    x = macro[:,0] * 1e3 #in mm
    y = macro[:,2] * 1e3 #in mm
    px = macro[:,1] * 1e3 #in MeV
    py = macro[:,3] * 1e3 #in MeV
    z = 0
    t = macro[:,4] #in ns
    pz = macro[:,5] #in MeV
    
    def dpsi_n1_inv(dpsi_n0, dW_n0, W_kin, w_RF, L):
        W = W_kin + cp.m_mu
        beta = np.sqrt(1 - (cp.m_mu*cp.m_mu)/(W*W))
        gamma = W/cp.m_mu
        return dpsi_n0 + w_RF * dW_n0 * L / (cp.m_mu*c * (beta*gamma)**3)
    
    ts = t*1e-9 #time in [s]
    W_kin = ((Pref*Pref + m_mu*m_mu)**0.5 - m_mu) * 1e9 #Ekin in [eV]
    p = (px**2 + py**2 + pz**2)**0.5 * 1e-3 #p total in [GeV]
    dW = (p**2 + m_mu**2)**0.5 * 1e9 #E total in [eV]
    w_RF = 200 * 1e6 #random frequency
    dpsi = ts * w_RF
    
    #Focal length
    L_focal = 0
    ts0 = dpsi_n1_inv(dpsi, dW, W_kin, w_RF, L_focal) / w_RF
    ts0 =  ts0 - np.mean(ts0 )
    t = ts0 * 1e9
    
    PDGid = -13
    TrkId = 0
    Parent = 0
    weight = 1.0
    mm_c_to_ns = 1/c *1E9
    
    with open(f'170325_BeamInput_{N}_Cell1_of_10_GA_{Bfield}T.txt', 'w') as file:
        # Write the header
        file.write('#BLTrackFile File generated by RFTrack\n')
        file.write('#x [mm] y [mm] z [mm] Px [MeV/c] Py [MeV/c] Pz [MeV/c] t [ns] PDGid EvNum TrkId Parent weight\n')
        
        # Write each row of data
        for i in range(N):
            EvNum = i + 1
            file.write(f'{x[i]} {y[i]} {z} {px[i]} {py[i]} {pz[i]} {t[i]} {PDGid} {EvNum} {TrkId} {Parent} {weight}\n')

def readfile(filename, types='fieldmap'):
    if types == 'for009':
        # Define the keys as per the data columns
        keys = ['IEVT', 'IPNUM', 'IPTYP', 'IPFLG', 'JSRG', 'T', 'X', 'Y', 'Z', 'Px', 'Py', 'Pz', 'Bx', 'By', 'Bz', 'Weight', 'Ex', 'Ey', 'Ez', 'SARC', 'POLx', 'POLy', 'POLz']

    if types == 'profile':
        keys = ['Z', 'N', 'meanX', 'sigmaX', 'meanY', 'sigmaY', 'emitX', 'emitY', 'emitTrans', 'betaX', 'betaY', 'betaTrans', 'alphaX', 'alphaY', 'alphaTrans', 'meanP']
    
    if types == 'fieldmap':
        keys = ['x','y','z','t','Bx','By','Bz','Ex','Ey','Ez']
   
    # Initialize an empty dictionary with the required keys
    field_dict = {key: [] for key in keys}
    
    # Read the file
    with open(filename, 'r') as file:
        # Skip the header lines
        next(file)
        next(file)
        if types == 'for009' or 'profile':
            next(file)
        
        # Process each line in the file
        for line in file:
            # Split the line into components
            values = line.split()
            
            # Append each value to the corresponding list in the dictionary
            for i, key in enumerate(keys):
                field_dict[key].append(float(values[i]))
    
    # Print the dictionary to verify the result
    return(field_dict)

def compute_emit_from_phasespace(beam):
    m_mu = 0.105658375
    ref_charge = 0.299792458
    X, PX, Y, PY, T, PZ = beam['X'], beam['Px'], beam['Y'], beam['Py'], 1E9*beam['T'], beam['Pz']
    BZ = beam['Bz']
    E = (PZ*PZ + PY*PY + PX*PX + m_mu*m_mu)**0.5

    filt = True

    if filt:
        # Stack the variables for easier filtering
        data = np.stack([X, PX, Y, PY, T, E])
        # Calculate the mean and standard deviation of each variable
        means = np.mean(data, axis=1)
        stds = np.std(data, axis=1)
        # Identify high amplitude particles (above 5 sigma)
        sigma = 5
        filtered_indices = np.all(np.abs(data - means[:, np.newaxis]) < sigma * stds[:, np.newaxis], axis=0)
        # Filter the data
        filtered_data = data[:, filtered_indices]
        
        # Compute the covariance matrix of the filtered data
        Cov = np.cov(filtered_data)
    else:
        Cov = np.cov([X,PX,Y,PY,T,E])
    Covx = Cov[0:2, 0:2]
    Covy = Cov[2:4, 2:4]
    Cov4D = Cov[0:4, 0:4]
    Covz = Cov[4:6, 4:6]
    
    emi4D_ = np.linalg.det(Cov4D)**0.25 / m_mu 
    emix_ = np.linalg.det(Covx)**0.5 / m_mu
    emiy_ = np.linalg.det(Covy)**0.5 / m_mu 
    emiz_ = np.linalg.det(Covz)**0.5 #in GeVns == eVs
    
    Pzaverage = np.mean(PZ)
    Bzaverage = np.mean(BZ)
    emi4D_geo = emi4D_ * m_mu / Pzaverage
    emix_geo = emix_ * m_mu / Pzaverage
    emiy_geo = emiy_ * m_mu / Pzaverage
    
    betax_ = Covx[0][0] / emix_geo
    betay_ = Covy[0][0] / emiy_geo
    beta_perp_ = (Covx[0][0] + Covy[0][0])*0.5/emi4D_geo
    alphax_ = -Covx[0][1] / emix_geo
    alphay_ = -Covy[0][1] / emiy_geo
    alpha_perp_ = -(Covy[0][1]+Covx[0][1]) *0.5 / emi4D_geo
    gamma_perp_ = (Covy[1][1]+Covx[1][1]) *0.5 / emi4D_geo / Pzaverage
    
    xpy = Cov[0][3]
    ypx = Cov[1][2]
    xx = Cov[0][0]
    yy = Cov[2][2]
    
    xc = X - np.mean(X)
    yc = Y - np.mean(Y)
    pxc = PX - np.mean(PX)
    pyc = PY - np.mean(PY)
    kappa = ref_charge * Bzaverage * 0.5 / Pzaverage
    L_ = (Bzaverage*ref_charge*0.5*(xx + yy) - (ypx - xpy )) * 0.5 / m_mu / emi4D_
    
    #term1 = beta_perp_*(pxc*pxc + pyc*pyc)/Pzaverage 
    #term2 = gamma_perp_*Pzaverage*( xc*xc + yc*yc )
    #term3 = 2*alpha_perp_*(xc*pxc + yc*pyc)
    #term4 = 2*(beta_perp_*kappa - L_)*(-xc*pyc + yc*pxc)

    try:
        Cov4D_inv = np.linalg.inv(Cov4D)
    except np.linalg.LinAlgError:
        print(filtered_data)
        return np.nan, np.nan, np.nan
    U = np.stack([X, PX, Y, PY], axis=1)
    A = np.einsum('ij,jk,ik->i', U , Cov4D_inv, U ) * emi4D_geo

    ampsq_sp = A
    #ampsq_sp = (term1 + term2 + term3 +term4)/m_mu
    
    CovL = np.cov([T, E, ampsq_sp])
    AAT = CovL[2,2]
    emiL_ = (np.linalg.det(CovL) )**(0.5) / m_mu * ref_charge / (AAT**0.5)
    return emi4D_, emiL_, emiz_


def plot_solenoid(solenoid, Bmax, cmap='viridis'):
    # Normalize B_peak for color mapping
    norm = mcolors.Normalize(vmin=0, vmax=Bmax)
    cmap = plt.colormaps.get_cmap(cmap)
    color = cmap(norm(solenoid.current_density))
    
    rect = patches.Rectangle(
        (solenoid.position - solenoid.L_sol / 2, -solenoid.radius_outer / 2),
        solenoid.L_sol,
        solenoid.radius_outer,
        linewidth=1,
        edgecolor='k',
        facecolor=color
    )
    return rect


import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as mcolors
import matplotlib.patches as patches

def plot_solenoid(solenoid, Bmax, cmap='viridis'):
    # Normalize B_peak for color mapping
    norm = mcolors.Normalize(vmin=-Bmax, vmax=Bmax)
    cmap = plt.colormaps.get_cmap(cmap)
    color = cmap(norm(solenoid.current_density))
    
    rect_outer = patches.Rectangle(
        (solenoid.position - solenoid.L_sol / 2, solenoid.radius_inner),
        solenoid.L_sol,
        solenoid.radius_outer,
        linewidth=1,
        edgecolor='k',
        facecolor=color
    )
    rect_inner = patches.Rectangle(
        (solenoid.position - solenoid.L_sol / 2, -solenoid.radius_inner),
        solenoid.L_sol,
        -solenoid.radius_outer,
        linewidth=1,
        edgecolor='k',
        facecolor=color
    )
    return rect_outer, rect_inner

def solve_ode_currentdensity(params, Momentum, beta_initial, stream):
    
    # Update matchers
    if len(params) == 4:
        if stream=='Up':
            MU1.current_density = params[0]
            MU2.current_density = params[1]
            MU3.current_density = params[2]
            MU4.current_density = params[3]

            MD1.current_density = params[3]
            MD2.current_density = params[2]
            MD3.current_density = params[1]
            MD4.current_density = params[0]
        if stream=='Down':
            MD1.current_density = params[3]
            MD2.current_density = params[2]
            MD3.current_density = params[1]
            MD4.current_density = params[0]
    if len(params) == 8:
        MU1.current_density = params[0]
        MU2.current_density = params[1]
        MU3.current_density = params[2]
        MU4.current_density = params[3]

        MD1.current_density = params[4]
        MD2.current_density = params[5]
        MD3.current_density = params[6]
        MD4.current_density = params[7]

    mag_field = cp.MagneticField()
    [mag_field.add_solenoid(solenoid) for solenoid in sol_list]

    B_superposed = mag_field.superposed_field_z(s)
    kappa = abs(cp.Gc_2 * B_superposed / Momentum)
    kappa_interp = interp1d(s, kappa, kind='cubic', fill_value="extrapolate")
    b0 = beta_initial

    solution = odeint(cp.beta_system, b0, s, args=(kappa_interp, L))
    b1 = solution[:, 0]  #Extract b1 values
    b2 = solution[:, 1]  #Extract b2 values
    return b1, b2